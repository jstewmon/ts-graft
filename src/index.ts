import { basename, dirname, sep as pathSep } from "path";
import readPkgUp from "read-pkg-up";
import resolveCwd from "resolve-cwd";
import {
  InterfaceDeclaration,
  Node,
  Project,
  Structure,
  SyntaxKind,
  TypeAliasDeclaration,
  SourceFile,
  Identifier,
  ScriptTarget,
  ExportableNode,
} from "ts-morph";
import { nodeModuleNameResolver } from "typescript";
import { Config } from "./config";
export * as config from "./config";

interface GraftParams {
  project?: Project;
  config: Config;
}

interface GraftFileParams {
  project: Project;
  options: GraftFileOptions;
}

interface GraftFileOptions {
  source: string;
  output: string;
  include: string[];
}

interface ResolveNodesParams {
  source: SourceFile;
  output: SourceFile;
  include: string[];
}

export default {
  async graft(params: GraftParams): Promise<void> {
    const {
      project = new Project({ skipAddingFilesFromTsConfig: true }),
      config,
    } = params;
    await Promise.all(
      config.grafts.map((options) =>
        this.graftFile({ project, options }).then((outputFile) =>
          outputFile.save()
        )
      )
    );
  },

  async graftFile(params: GraftFileParams): Promise<SourceFile> {
    const {
      project,
      options: { source, include, output },
    } = params;
    const sourceFilename = resolveCwd(source);
    const {
      packageJson: { name: packageName, version: packageVersion } = {
        name: "unknown",
        version: "unknown",
      },
    } = (await readPkgUp({ cwd: dirname(sourceFilename) })) || {};
    const inputSourceFile = project.addSourceFileAtPath(sourceFilename);
    const outputSourceFile = project.createSourceFile(output, undefined, {
      overwrite: true,
    });
    outputSourceFile.addStatements([
      `// Generated by resolving ${source} from ${packageName}@${packageVersion}`,
    ]);
    this.graftNodes({
      source: inputSourceFile,
      output: outputSourceFile,
      include,
    });
    return outputSourceFile;
  },

  graftNodes(params: ResolveNodesParams): void {
    const { source, output, include } = params;
    const resolvedNodes = new Set<
      InterfaceDeclaration | TypeAliasDeclaration
    >();
    const unresolvedNodes = new Set<
      InterfaceDeclaration | TypeAliasDeclaration
    >(
      include.map((type) => {
        const node = source.getInterface(type) ?? source.getTypeAlias(type);
        if (!node) {
          throw new Error(
            `${type} does not refer to an interface or type alias`
          );
        }
        return node;
      })
    );

    while (unresolvedNodes.size > 0) {
      for (const node of unresolvedNodes.values()) {
        unresolvedNodes.delete(node);
        resolvedNodes.add(node);

        // Declarations in lib files are never exported because they are globally
        // available. Since we extract the types to a module, we export them.
        node.setIsExported(true);

        // Find all descendant identifiers which reference an interface or type
        // alias, and add them to the unresolved list.
        for (const id of node.getDescendantsOfKind(SyntaxKind.Identifier)) {
          for (const dn of id.getDefinitionNodes()) {
            if (
              Node.isInterfaceDeclaration(dn) ||
              Node.isTypeAliasDeclaration(dn)
            ) {
              if (!resolvedNodes.has(dn)) {
                unresolvedNodes.add(dn);
              }
            }
          }
        }
      }
    }

    const resolvedStructures = Array.from(resolvedNodes).map((node) =>
      node.getStructure()
    );
    output.addInterfaces(resolvedStructures.filter(Structure.isInterface));
    output.addTypeAliases(resolvedStructures.filter(Structure.isTypeAlias));
  },
};

export function graftLibDefinitions(params: GraftParams) {
  const project =
    params.project ??
    new Project({
      compilerOptions: {
        target: ScriptTarget.ES2015,
      },
    });
  for (const graft of params.config.grafts) {
    const sourceFile = project.addSourceFileAtPath(graft.source);
    const outputFile = project.createSourceFile(graft.output, undefined, {
      overwrite: true,
    });
    const libDefinitionNodes = gatherLibDefinitions(
      gatherIdentifiers(sourceFile),
      new Set(graft.include)
    );
    for (const node of libDefinitionNodes) {
      const newNode = transposeDeclaration(outputFile, node);
      if (newNode) newNode.setIsExported(true);
    }
    outputFile.saveSync();
  }
}

export function transposeDeclaration(
  outputFile: SourceFile,
  node: Node
): ExportableNode | undefined {
  if (Node.isVariableDeclaration(node)) {
    return outputFile.addVariableStatement(
      node.getVariableStatement()!.getStructure()
    );
  } else if (Node.isInterfaceDeclaration(node)) {
    return outputFile.addInterface(node.getStructure());
  } else if (Node.isClassDeclaration(node)) {
    return outputFile.addClass(node.getStructure());
  } else if (Node.isTypeAliasDeclaration(node)) {
    return outputFile.addTypeAlias(node.getStructure());
  } else if (Node.isFunctionDeclaration(node)) {
    const structure = node.getStructure();
    if (Structure.isFunction(structure)) {
      return outputFile.addFunction(structure);
    }
  }
}

export function gatherLibDefinitions(
  identifiers: Identifier[],
  includeLibs: Set<string> = new Set()
): Node[] {
  const result: Node[] = [];
  const rm: Map<Node, Node[]> = new Map();
  const urm: Map<Node, Node[]> = new Map();
  const resolved: Set<Node> = new Set();
  const unresolved: Set<Node> = new Set();
  function enqueue(ids: Identifier[], path: Node[]) {
    ids
      .flatMap((id) => id.getDefinitionNodes())
      .forEach((n) => {
        if (resolved.has(n)) return;
        if (path.length === 0) {
          unresolved.add(n);
          urm.set(n, path);
        } else {
          // only include abstract types of indirect identifiers
          switch (n.getKind()) {
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.TypeAliasDeclaration:
              unresolved.add(n);
              urm.set(n, path);
              break;
          }
        }
      });
  }
  enqueue(identifiers, []);
  while (unresolved.size > 0) {
    for (const [node, path] of urm.entries()) {
      unresolved.delete(node);
      urm.delete(node);
      resolved.add(node);
      rm.set(node, path);

      const lib = tsLibName(node);
      if (lib && (includeLibs.size === 0 || includeLibs.has(lib))) {
        result.push(node);
      }

      enqueue(gatherIdentifiers(node), [...path, node]);
    }
  }

  return result;
}

export function gatherIdentifiers(node: Node): Identifier[] {
  return node.getDescendantsOfKind(SyntaxKind.Identifier);
}

export function gatherNodes(
  node: Node,
  predicate: (node: Node) => boolean
): Node[] {
  const result: Node[] = [];
  node.forEachDescendant((n) => {
    if (predicate(n)) {
      result.push(n);
    }
  });
  return result;
}

export function tsLibName(node: Node): string | undefined {
  const filePath = node.getSourceFile().getFilePath();
  const pathParts = filePath.split(pathSep);
  const [grandParent, parent, file] = pathParts.slice(-3);
  if (grandParent === "typescript" && parent === "lib") {
    return basename(file, ".d.ts").match(/^lib\.(?<lib>.*)$/)?.groups?.lib;
  }
}
